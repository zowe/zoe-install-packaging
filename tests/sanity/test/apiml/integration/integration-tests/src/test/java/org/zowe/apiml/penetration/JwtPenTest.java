/*
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 */
package org.zowe.apiml.penetration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.restassured.RestAssured;
import org.json.JSONObject;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.zowe.apiml.gatewayservice.SecurityUtils;
import org.zowe.apiml.security.HttpsConfig;
import org.zowe.apiml.security.common.ticket.TicketRequest;
import org.zowe.apiml.util.config.ConfigReader;
import org.zowe.apiml.util.config.EnvironmentConfiguration;
import org.zowe.apiml.util.config.TlsConfiguration;

import java.nio.charset.StandardCharsets;
import java.security.PublicKey;
import java.util.Base64;
import java.util.stream.Stream;

import static io.restassured.RestAssured.given;
import static io.restassured.http.ContentType.JSON;
import static org.apache.http.HttpStatus.SC_OK;
import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
import static org.hamcrest.core.Is.is;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.zowe.apiml.gatewayservice.SecurityUtils.getConfiguredSslConfig;
import static org.zowe.apiml.security.SecurityUtils.loadPublicKey;

/*
 * Penetration testing of JWT
 *
 * Based on the following article:
 * https://medium.com/101-writeups/hacking-json-web-token-jwt-233fe6c862e6
 *
 * It tests three type of endpoints:
 * - query endpoint (verify JWT token)
 * - PassTicket endpoint on Gateway (covered by Spring Security, see authorized access)
 * - PassTicket endpoint on Discoverable client (through server command's treatment)
 *
 * On each type of endpoint are tested those cases:
 * - success (real right-formed JWT)
 * - unauthorized
 *      - token without signature
 *      - token with changed iss (realm)
 *      - token with changed username (sub)
 *      - token signed with public key
 */
public class JwtPenTest {

    private static final EnvironmentConfiguration ENV = ConfigReader.environmentConfiguration();

    private static final String SCHEME = ENV.getGatewayServiceConfiguration().getScheme();
    private static final String HOST = ENV.getGatewayServiceConfiguration().getHost();
    private static final int PORT = ENV.getGatewayServiceConfiguration().getPort();
    private static final String APPLICATION_NAME = ENV.getDiscoverableClientConfiguration().getApplId();
    private static final String USERNAME = ENV.getCredentials().getUser();
    private static final String PASSWORD = ENV.getCredentials().getPassword();

    private static final String BASE_PATH = "/api/v1/gateway";
    private static final String QUERY_ENDPOINT = "/auth/query";
    private static final String STATICCLIENT_BASE_PATH = "/api/v1/staticclient";
    private static final String PASSTICKET_TEST_ENDPOINT = "/passticketTest";
    private static final String PASSTICKET_ENDPOINT = "/auth/ticket";

    private static final String QUERY_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, QUERY_ENDPOINT);
    private static final String PASSTICKET_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, STATICCLIENT_BASE_PATH, PASSTICKET_TEST_ENDPOINT);
    private static final String GATEWAY_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, PASSTICKET_ENDPOINT);

    private static String validToken;

    public static String getValidToken() {
        if (validToken == null) {
            RestAssured.port = PORT;
            RestAssured.basePath = "/";
            RestAssured.useRelaxedHTTPSValidation();
            RestAssured.config = RestAssured.config().sslConfig(getConfiguredSslConfig());
            validToken = SecurityUtils.gatewayToken(USERNAME, PASSWORD);
        }

        return validToken;
    }

    private static String getPart(int index) {
        final String[] parts = validToken.split("\\.");
        return parts[index];
    }

    private static String getHeader() {
        return getPart(0);
    }

    private static String getPayload() {
        return getPart(1);
    }

    private static String getSignature() {
        return getPart(2);
    }

    private static String replaceClaim(String originalPaylad, String name, String value) {
        final String decoded = new String(Base64.getDecoder().decode(originalPaylad), StandardCharsets.UTF_8);
        final JSONObject json = new JSONObject(decoded);
        json.put(name, value);
        return Base64.getEncoder().encodeToString(json.toString().getBytes(StandardCharsets.UTF_8));
    }

    private static String getTokenNoneAlgorithm() {
        final JSONObject jsonObject = new JSONObject();
        jsonObject.put("alg", "none");
        final String noneHeader = Base64.getEncoder().encodeToString(jsonObject.toString().getBytes(StandardCharsets.UTF_8));
        return String.format("%s.%s.", noneHeader, getPayload());
    }

    private static PublicKey getPublicKey() {
        TlsConfiguration tlsConfiguration = ConfigReader.environmentConfiguration().getTlsConfiguration();
        HttpsConfig config = HttpsConfig.builder()
            .keyAlias(tlsConfiguration.getKeyAlias())
            .keyStore(tlsConfiguration.getKeyStore())
            .keyPassword(tlsConfiguration.getKeyPassword())
            .keyStorePassword(tlsConfiguration.getKeyStorePassword())
            .keyStoreType(tlsConfiguration.getKeyStoreType())
            .build();
        PublicKey publicKey = loadPublicKey(config);
        assertNotNull(publicKey);
        return publicKey;
    }

    private static String getTokenWithHs256Signature() {
        PublicKey publicKey = getPublicKey();

        String payload = getPayload();
        String decodedPayload = new String(Base64.getDecoder().decode(payload), StandardCharsets.UTF_8);

        return Jwts.builder()
            .setPayload(decodedPayload)
            .signWith(SignatureAlgorithm.HS256, publicKey.getEncoded())  // Library does not allow me to use public key for signing directly
            .compact();
    }

    private static String getTokenChangedRealm() {
        final String newPayload = replaceClaim(getPayload(), "iss", "ThirdParty");
        return String.format("%s.%s.%s", getHeader(), newPayload, getSignature());
    }

    private static String getTokenChangedUser() {
        final String newPayload = replaceClaim(getPayload(), "sub", "admin");
        return String.format("%s.%s.%s", getHeader(), newPayload, getSignature());
    }

    public static Stream<Arguments> getTokens() {
        return Stream.of(
            Arguments.of("validJwt", getValidToken(), SC_OK),
            Arguments.of("noSignJwt", getTokenNoneAlgorithm(), SC_UNAUTHORIZED),
            Arguments.of("publicKeySignedJwt", getTokenWithHs256Signature(), SC_UNAUTHORIZED),
            Arguments.of("changedRealmJwt", getTokenChangedRealm(), SC_UNAUTHORIZED),
            Arguments.of("changedUserJwt", getTokenChangedUser(), SC_UNAUTHORIZED)
        );
    }

    @ParameterizedTest(name = "call query endpoint with {0} to receive response code {2}")
    @MethodSource("getTokens")
    public void givenJwt_thenCheckResponse_whenCallQueryEndpoint(String tokenType, String token, int status) {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(status));
        //@formatter:on
    }

    @ParameterizedTest(name = "call passticket service with {0} to receive response code {2}")
    @MethodSource("getTokens")
    @Disabled
    public void givenJwt_thenCheckResponse_whenCallPassTicketService(String tokenType, String token, int status) {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(status));
        //@formatter:on
    }

    @ParameterizedTest(name = "call passticket endpoint with {0} to receive response code {2}")
    @MethodSource("getTokens")
    public void givenJwt_thenCheckResponse_whenCallPassTicketEndpoint(String tokenType, String token, int status) {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + token)
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(status));
        //@formatter:on
    }

}
